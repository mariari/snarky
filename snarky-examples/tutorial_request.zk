/* Let's talk a bit more about requests. */

/* Requests let you "ask for help" in computing something.
   Specifically, if you know a function f such that it's
   easier to check if f(x) = y than to compute it, you can
   use requests to replace computing by checking. */

/* Let's do a simple example.
   Consider field division.

   Input: x, y
   Output: x / y, or in other words, z such that z * y = x.

   Luckily snarky predefines division for us, but if it
   didn't, we could define it using requests.

   Let f(x,y) = x / y.
   First, how can we check using + and * that

   z = f(x, y) = x / y ?

   Well, we just check z * y = x!

   Here's what this looks like with requests.
 */

/* First, we declare a Div request. It says this
   request takes two field elements as arguments and
   returns a field element. */
request(field) Div(field, field);

let div = fun (x, y) => {
  /* Here we actually make the request.
     Later, we'll define a handler to respond to this
     request by providing a value.
   */
  let z = request { Div(x, y); };
  /* This function enforces the "rank 1" (i.e., r1) constraint that
     z * y = x
  */
  assert_r1(z, y, x);
  /* If we made it throough the assertion, the provided value is indeed
     x / y, so we can return it. */
  z ;
};

/* A request can only return values of certain types.
   In particular, it can only return values which are
   made of field elements and booleans and which have
   a known size. Basically tuples and records.
*/

/* Tuples for example. */
request((boolean, field)) Test(field);

let test : unit -> (boolean, field) = fun () => {
  let x : (boolean, field) = request { Test(0); };
  x ;
};

type point = {
  x : field,
  y : field
};

request(point) Get_point;

let test1 = fun () => {
  let x : point = request { Get_point; };
  x ;
};

/* Let's look at how to handle or respond to requests.

   First, we need the concepts of "prover scope" and "verifier scope".

   Verifier scope:
   This is the normal scope in snarky. Basically the only things you can
   do with field elements are add them, multiply them, request and make 
   assertions about them. All other functions on field elements are defined
   using these primitives. This is because of the way the underlying SNARK
   constructions (the compilation target) work. They only can certify computations
   consisting of adds and multiplies.

   Prover scope:
   When responding to a request, you can perform whatever kind of computation you'd like,
   and so you gain access to additional functions on field elements.
   For example, normally, there are no functions

   Field.equal : field -> field -> bool
   Field.to_bits : field -> field -> list(bool)

   (bool, not boolean). But when handling requests, you do have access to
   such a function.

   We call the scope when handling requests "prover scope" because it permits you to perform
   computations that can be performed by the prover.
*/

/* Actually, even multiplication (i.e., *) is implemented this way.
   Sort of like the following. */
request(field) Mul(field, field);

